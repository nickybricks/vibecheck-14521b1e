---
phase: 03-api-integration
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - backend/api/schemas/sentiment.py
  - backend/api/routes/sentiment.py
  - backend/api/routes/entities.py
  - backend/main.py
autonomous: true

must_haves:
  truths:
    - "GET /entities/{id}/sentiment returns time-series data for entity"
    - "Query parameters filter by date range (start_date, end_date)"
    - "Query parameter selects period (hourly or daily)"
    - "Responses are paginated with cursor for large datasets"
    - "Invalid dates return 400 error"
    - "Non-existent entity returns 404 error"
  artifacts:
    - path: "backend/api/schemas/sentiment.py"
      provides: "Time-series response schemas"
      exports: ["SentimentPointSchema", "SentimentTimeseriesResponse"]
    - path: "backend/api/routes/sentiment.py"
      provides: "Sentiment time-series query endpoint"
      exports: ["router"]
    - path: "backend/api/routes/entities.py"
      contains: "latest_sentiment populated from SentimentTimeseries"
  key_links:
    - from: "backend/api/routes/sentiment.py"
      to: "db.models.SentimentTimeseries"
      via: "Filtered select queries with date range"
      pattern: "select\\(SentimentTimeseries\\)"
    - from: "backend/api/routes/entities.py"
      to: "db.models.SentimentTimeseries"
      via: "Subquery to get latest sentiment per entity"
      pattern: "select\\(SentimentTimeseries\\)\\.where\\(\\.entity_id\\)"
---

<objective>
Implement sentiment time-series query endpoint with date filtering, pagination, and latest sentiment calculation.

Purpose: Enable frontend to chart sentiment trends over time for specific entities with configurable granularity.
Output: Working GET /entities/{id}/sentiment endpoint with date range filtering, period selection, and cursor pagination.
</objective>

<execution_context>
@/Users/daniswhoiam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/daniswhoiam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-api-integration/03-RESEARCH.md
@backend/db/models.py
@backend/db/session.py
@backend/api/routes/entities.py
@.planning/phases/03-api-integration/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create Pydantic schemas for sentiment time-series</name>
  <files>backend/api/schemas/__init__.py</files>
  <files>backend/api/schemas/sentiment.py</files>
  <action>
    Create backend/api/schemas/sentiment.py with time-series response schemas:

    1. Create backend/api/schemas/__init__.py (if not exists):
       - Empty file

    2. Create backend/api/schemas/sentiment.py with:
       - SentimentPointSchema: Single time-series data point
         * timestamp (datetime) - ISO 8601
         * period (str) - "hourly" or "daily"
         * sentiment_mean (float | None)
         * sentiment_min (float | None)
         * sentiment_max (float | None)
         * sentiment_std (float | None)
         * article_count (int | None)
         * reddit_sentiment (float | None)
         * reddit_thread_count (int | None)

       - SentimentTimeseriesResponse: Paginated time-series response
         * entity_id (int)
         * period (str)
         * data (List[SentimentPointSchema])
         * next_cursor (str | None) - ISO timestamp for pagination
         * has_more (bool)

    Use Pydantic v2 syntax with from_attributes=True.
    Reference backend/db/models.py SentimentTimeseries model for field types.
  </action>
  <verify>
    Python: from backend.api.schemas.sentiment import SentimentPointSchema, SentimentTimeseriesResponse
    No import errors
  </verify>
  <done>
    SentimentPointSchema matches SentimentTimeseries ORM model fields
    SentimentTimeseriesResponse includes pagination fields (next_cursor, has_more)
  </done>
</task>

<task type="auto">
  <name>Implement GET /entities/{id}/sentiment endpoint</name>
  <files>backend/api/routes/sentiment.py</files>
  <action>
    Create backend/api/routes/sentiment.py with time-series query endpoint:

    1. Import dependencies:
       - APIRouter, Depends, HTTPException, Query from fastapi
       - AsyncSession from sqlalchemy.ext.asyncio
       - select from sqlalchemy
       - datetime, Optional from typing
       - SentimentTimeseries from db.models
       - SentimentPointSchema, SentimentTimeseriesResponse from api.schemas.sentiment
       - get_session from db.session
       - Entity from db.models

    2. Create router: APIRouter(prefix="/entities", tags=["sentiment"])

    3. Implement GET /entities/{entity_id}/sentiment endpoint:
       Parameters:
       - entity_id (int) - path
       - start_date (datetime | None) - Query, ISO 8601
       - end_date (datetime | None) - Query, ISO 8601
       - cursor (str | None) - Query, ISO timestamp for pagination
       - limit (int) - Query, default 100, ge 1, le 1000
       - period (str) - Query, default "daily", regex="^(hourly|daily)$"
       - session (AsyncSession) - Depends(get_session)

       Query logic:
       a. Verify entity exists: select(Entity).where(Entity.id == entity_id)
          If not found, raise HTTPException(404, "Entity not found")

       b. Build base query:
          query = select(SentimentTimeseries).where(
              SentimentTimeseries.entity_id == entity_id,
              SentimentTimeseries.period == period
          )

       c. Apply filters:
          - if start_date: query = query.where(SentimentTimeseries.timestamp >= start_date)
          - if end_date: query = query.where(SentimentTimeseries.timestamp <= end_date)
          - if cursor: Parse ISO timestamp, query = query.where(SentimentTimeseries.timestamp < cursor_time)

       d. Order and limit:
          query = query.order_by(SentimentTimeseries.timestamp.desc()).limit(limit)

       e. Execute and return SentimentTimeseriesResponse:
          result = await session.execute(query)
          data = result.scalars().all()
          points = [SentimentPointSchema.model_validate(ts) for ts in data]
          next_cursor = points[-1].timestamp.isoformat() if points else None
          has_more = len(points) == limit

    4. Add comprehensive docstring with parameter descriptions

    NOTE: Do not validate datetime format in endpoint - let FastAPI's automatic validation handle 400 errors
  </action>
  <verify>
    Run: docker compose exec backend python -c "from backend.api.routes.sentiment import router; print([r.path for r in router.routes])"
    Output includes: /entities/{entity_id}/sentiment
  </verify>
  <done>
    GET /entities/{id}/sentiment accepts all query parameters
    Query filters by entity_id, period, date range, and cursor
    Response returns paginated data with next_cursor and has_more
  </done>
</task>

<task type="auto">
  <name>Populate latest_sentiment in entity detail endpoint</name>
  <files>backend/api/routes/entities.py</files>
  <action>
    Update GET /entities/{entity_id} endpoint in backend/api/routes/entities.py:

    1. Import SentimentTimeseries from db.models

    2. Modify entity detail query to include latest sentiment:
       After fetching entity, add subquery:
       - Query: select(SentimentTimeseries.sentiment_mean)
                .where(SentimentTimeseries.entity_id == entity_id)
                .where(SentimentTimeseries.period == "daily")
                .order_by(SentimentTimeseries.timestamp.desc())
                .limit(1)
       - Execute: latest_result = await session.execute(subquery)
       - Get scalar: latest_sentiment = latest_result.scalar_one_or_none()

    3. Pass latest_sentiment to EntityDetailSchema:
       return EntityDetailSchema.model_validate(entity, latest_sentiment=latest_sentiment)

    4. Remove TODO comment about populating latest_sentiment

    This provides the most recent daily sentiment average for each entity.
  </action>
  <verify>
    Run: curl http://localhost:8000/entities/1
    Response includes: latest_sentiment field with float value or null
  </verify>
  <done>
    GET /entities/{id} returns latest_sentiment from most recent daily SentimentTimeseries entry
    Returns null if no time-series data exists for entity
  </done>
</task>

<task type="auto">
  <name>Register sentiment router with FastAPI app</name>
  <files>backend/main.py</files>
  <action>
    Update backend/main.py to include sentiment router:

    1. Add import below entities import:
       from api.routes import sentiment

    2. Below app.include_router(entities.router), add:
       app.include_router(sentiment.router)

    This makes the sentiment endpoints available at /entities/{id}/sentiment path.
  </action>
  <verify>
    Run: docker compose restart backend && docker compose logs backend | grep "Application startup"
    Then: curl http://localhost:8000/openapi.json | jq '.paths."/entities/{entity_id}/sentiment"'
    Output shows GET operation documented
  </verify>
  <done>
    FastAPI app includes sentiment router
    GET /entities/{id}/sentiment returns 200 with SentimentTimeseriesResponse
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Restart backend: docker compose restart backend
2. Wait for startup: docker compose logs -f backend | grep "Application startup"
3. Test sentiment query: curl "http://localhost:8000/entities/1/sentiment?period=daily&limit=10"
   - Should return 200
   - Response should have entity_id, period, data array, next_cursor, has_more
   - Data points should have all sentiment fields (mean, min, max, std, article_count, reddit_sentiment)
4. Test date filtering: curl "http://localhost:8000/entities/1/sentiment?start_date=2026-02-01T00:00:00Z"
   - Should return only data points on or after start_date
5. Test pagination: curl "http://localhost:8000/entities/1/sentiment?limit=2"
   - If has_more=true, use next_cursor in second request
   - Second request: curl "http://localhost:8000/entities/1/sentiment?cursor={next_cursor}&limit=2"
   - Should return next page of data
6. Test 404: curl http://localhost:8000/entities/99999/sentiment
   - Should return 404 with "Entity not found" message
7. Test latest sentiment: curl http://localhost:8000/entities/1
   - Response should include latest_sentiment field populated
8. Verify period filtering: curl "http://localhost:8000/entities/1/sentiment?period=hourly"
   - Should return hourly data points if available

If any test fails, review task actions and verify implementation matches specifications.
</verification>

<success_criteria>
Phase 3 Plan 02 is complete when:
- GET /entities/{id}/sentiment returns time-series data with all sentiment fields
- Date range filtering (start_date, end_date) works correctly
- Cursor pagination returns consistent results with next_cursor and has_more
- Period parameter filters hourly vs daily data correctly
- Entity detail endpoint returns latest_sentiment from most recent daily entry
- All error cases (404 entity, invalid dates) return proper HTTP status codes
</success_criteria>

<output>
After completion, create `.planning/phases/03-api-integration/03-02-SUMMARY.md` with:
- Pagination strategy (cursor-based with timestamp)
- Query optimization decisions (indexes used, filtering approach)
- Latest sentiment calculation logic (daily period, most recent)
- API behavior with edge cases (empty data, invalid dates, non-existent entities)
- Next steps (Plan 03: CORS configuration for frontend integration)
</output>

---
phase: 01-foundation-storage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/Dockerfile
  - backend/requirements.txt
  - backend/pyproject.toml
  - backend/.env.example
  - docker-compose.yml
  - backend/config.py
  - backend/__init__.py
autonomous: true

must_haves:
  truths:
    - "Docker Compose starts PostgreSQL container with health check"
    - "Backend directory exists with correct Python project structure"
    - "Environment variables are configurable via .env file"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Local development environment with PostgreSQL"
      contains: "postgres:.*healthcheck"
    - path: "backend/Dockerfile"
      provides: "Backend container definition"
      min_lines: 15
    - path: "backend/requirements.txt"
      provides: "Python dependencies"
      contains: "fastapi.*sqlalchemy.*asyncpg"
    - path: "backend/.env.example"
      provides: "Environment variable template"
      contains: "DATABASE_URL"
  key_links:
    - from: "docker-compose.yml"
      to: "postgres healthcheck"
      via: "service_healthy condition"
      pattern: "condition:\\s*service_healthy"
    - from: "backend/config.py"
      to: "environment variables"
      via: "python-dotenv loading"
      pattern: "load_dotenv"
---

<objective>
Set up Docker Compose environment and backend Python project structure.

Purpose: Establish the foundation for local development with isolated PostgreSQL and FastAPI containers, ensuring consistent environment across development and future production.
Output: Working Docker Compose stack with backend scaffold and dependency management.
</objective>

<execution_context>
@/Users/daniswhoiam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/daniswhoiam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/daniswhoiam/Projects/vibecheck/.planning/PROJECT.md
@/Users/daniswhoiam/Projects/vibecheck/.planning/ROADMAP.md
@/Users/daniswhoiam/Projects/vibecheck/.planning/STATE.md
@/Users/daniswhoiam/Projects/vibecheck/.planning/phases/01-foundation-storage/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create backend directory structure and Python project files</name>
  <files>
    backend/__init__.py
    backend/config.py
    backend/pyproject.toml
    backend/requirements.txt
    backend/.env.example
  </files>
  <action>
Create backend directory with standard Python project structure:

1. Create backend/__init__.py (empty marker file)

2. Create backend/config.py with environment configuration:
   - Use python-dotenv to load .env file
   - Define Settings class with DATABASE_URL, ENVIRONMENT fields
   - Set default DATABASE_URL to postgresql+asyncpg://vibecheck:password@postgres:5432/vibecheck
   - Export settings instance for import by other modules

3. Create backend/pyproject.toml following research patterns:
   - Project name: "vibecheck-backend"
   - Version: "0.1.0"
   - Requires Python >=3.11
   - Dependencies: fastapi==0.115.0, uvicorn[standard]==0.30.0, pydantic==2.7.0, sqlalchemy==2.0.35, asyncpg==0.30.0, alembic==1.14.0, httpx==0.27.0, python-dotenv==1.0.0
   - Optional dev dependencies: pytest==8.0.0, pytest-asyncio==0.24.0, pytest-cov==5.0.0
   - Configure [tool.pytest.ini_options] with asyncio_mode = "auto"

4. Create backend/requirements.txt with exact pinned versions from research:
   - All dependencies from pyproject.toml
   - Dev dependencies included for local development

5. Create backend/.env.example template:
   - DATABASE_URL=postgresql+asyncpg://vibecheck:password@postgres:5432/vibecheck
   - ENVIRONMENT=development
   - SQL_ECHO=false
   - Comment explaining each variable purpose
  </action>
  <verify>
Files exist with correct content:
- ls backend/__init__.py backend/config.py backend/pyproject.toml backend/requirements.txt backend/.env.example
- grep "DATABASE_URL" backend/.env.example
- grep "fastapi.*0.115" backend/requirements.txt
  </verify>
  <done>
Backend directory structure created with pyproject.toml, requirements.txt, config.py, and .env.example template
  </done>
</task>

<task type="auto">
  <name>Create Docker Compose configuration with PostgreSQL healthcheck</name>
  <files>
    docker-compose.yml
    backend/Dockerfile
  </files>
  <action>
Create Docker Compose and Dockerfile following research patterns (INFR-01):

1. Create backend/Dockerfile:
   - FROM python:3.12-slim
   - WORKDIR /app
   - COPY requirements.txt and RUN pip install --no-cache-dir -r requirements.txt
   - COPY source code (COPY . .)
   - EXPOSE 8000
   - HEALTHCHECK using httpx to check http://localhost:8000/health (30s interval, 10s timeout)
   - CMD: uvicorn main:app --host 0.0.0.0 --port 8000 --reload

2. Create docker-compose.yml in project root:
   - version: '3.8'
   - Service "backend":
     * build: ./backend
     * ports: 8000:8000
     * environment: DATABASE_URL=postgresql+asyncpg://vibecheck:password@postgres:5432/vibecheck, ENVIRONMENT=development
     * volumes: ./backend:/app for live reload
     * depends_on postgres with condition: service_healthy
     * command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload
   - Service "postgres":
     * image: postgres:16-alpine
     * environment: POSTGRES_DB=vibecheck, POSTGRES_USER=vibecheck, POSTGRES_PASSWORD=password
     * ports: 5432:5432
     * volumes: postgres_data:/var/lib/postgresql/data
     * healthcheck: pg_isready -U vibecheck (5s interval, 5s timeout, 5 retries)
   - Volume: postgres_data

IMPORTANT: Backend depends_on postgres with "condition: service_healthy" to prevent connection failures on startup.
  </action>
  <verify>
Validate Docker Compose configuration:
- docker-compose config (validates YAML syntax)
- grep "service_healthy" docker-compose.yml
- grep "pg_isready" docker-compose.yml
- grep "python:3.12-slim" backend/Dockerfile
  </verify>
  <done>
Docker Compose configuration exists with PostgreSQL healthcheck and backend service that depends on healthy database
  </done>
</task>

<task type="auto">
  <name>Test Docker Compose stack startup</name>
  <files>
    N/A (verification only)
  </files>
  <action>
Verify Docker Compose stack can start successfully:

1. Ensure no conflicting containers running:
   - docker-compose down -v (clean up any existing containers)

2. Start PostgreSQL only to verify healthcheck:
   - docker-compose up -d postgres
   - Wait for healthy status (docker-compose ps should show "healthy")
   - Verify pg_isready succeeds

3. Stop services:
   - docker-compose down

Note: Backend service will not fully start yet (main.py doesn't exist), but this verifies PostgreSQL configuration is correct and healthcheck works.
  </action>
  <verify>
Commands succeed:
- docker-compose config (no errors)
- docker-compose up -d postgres && sleep 10 && docker-compose ps | grep "healthy"
- docker-compose down
  </verify>
  <done>
Docker Compose successfully starts PostgreSQL with working healthcheck, ready for backend integration in next plan
  </done>
</task>

</tasks>

<verification>
After completion, verify:
1. docker-compose.yml exists with postgres healthcheck and service_healthy dependency
2. backend/ directory exists with pyproject.toml, requirements.txt, Dockerfile, .env.example
3. docker-compose config validates successfully
4. docker-compose up -d postgres starts healthy PostgreSQL container
</verification>

<success_criteria>
- Docker Compose configuration is valid and starts PostgreSQL with healthcheck
- Backend directory structure follows Python best practices from research
- Environment variables are templated in .env.example
- PostgreSQL healthcheck prevents backend from starting before database is ready
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-storage/01-01-SUMMARY.md`
</output>

---
phase: 01-foundation-storage
plan: 03
type: execute
wave: 3
depends_on: ["02"]
files_modified:
  - backend/main.py
  - backend/api/__init__.py
  - backend/api/routes/__init__.py
  - backend/api/routes/health.py
  - backend/utils/__init__.py
  - backend/utils/constants.py
autonomous: false

must_haves:
  truths:
    - "FastAPI application starts successfully in Docker container"
    - "Health endpoint returns 200 with database connectivity status"
    - "Backend container depends on healthy PostgreSQL and starts only when DB is ready"
    - "Application uses lifespan events for database initialization"
    - "Curated entity list is defined as constants for Phase 2 ingestion"
  artifacts:
    - path: "backend/main.py"
      provides: "FastAPI application with lifespan management"
      min_lines: 30
      contains: "FastAPI.*lifespan.*app"
    - path: "backend/api/routes/health.py"
      provides: "Health check endpoint with database connectivity"
      contains: "GET.*health.*database"
    - path: "backend/utils/constants.py"
      provides: "Curated entity list"
      contains: "GPT-4o.*Claude.*Gemini.*Cursor.*Lovable"
  key_links:
    - from: "backend/main.py"
      to: "backend/db/session.py"
      via: "import engine"
      pattern: "from backend\\.db\\.session import.*engine"
    - from: "backend/api/routes/health.py"
      to: "database session"
      via: "get_session dependency"
      pattern: "Depends\\(get_session\\)"
    - from: "docker-compose.yml backend service"
      to: "uvicorn main:app"
      via: "command execution"
      pattern: "uvicorn main:app"
---

<objective>
Create FastAPI application with health endpoint and verify full stack startup.

Purpose: Establish working API server that integrates with PostgreSQL, proves Docker Compose orchestration works, and provides foundation for Phase 2 data ingestion and Phase 3 REST endpoints.
Output: Running FastAPI application accessible at http://localhost:8000 with /health endpoint confirming database connectivity.
</objective>

<execution_context>
@/Users/daniswhoiam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/daniswhoiam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/daniswhoiam/Projects/vibecheck/.planning/PROJECT.md
@/Users/daniswhoiam/Projects/vibecheck/.planning/ROADMAP.md
@/Users/daniswhoiam/Projects/vibecheck/.planning/STATE.md
@/Users/daniswhoiam/Projects/vibecheck/.planning/phases/01-foundation-storage/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create FastAPI application with lifespan management</name>
  <files>
    backend/main.py
  </files>
  <action>
Create FastAPI application following research patterns:

1. Create backend/main.py:
   - Import contextlib.asynccontextmanager, FastAPI
   - Import CORSMiddleware from fastapi.middleware.cors
   - Import engine from backend.db.session
   - Import Base from backend.db.base
   - Import health router (will be created next)

2. Define lifespan context manager:
   - @asynccontextmanager async def lifespan(app: FastAPI)
   - Startup: print "Starting up application..."
   - Startup: async with engine.begin() as conn: await conn.run_sync(Base.metadata.create_all)
   - yield
   - Shutdown: print "Shutting down application..."
   - Shutdown: await engine.dispose()

3. Create FastAPI app instance:
   - app = FastAPI(title="VibeCheck API", description="Sentiment tracking for AI entities", version="0.1.0", lifespan=lifespan)

4. Add CORS middleware:
   - app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"])
   - Comment: "Restrict origins in production"

5. Include routers:
   - from backend.api.routes import health
   - app.include_router(health.router)

CRITICAL: Lifespan creates tables on startup (Base.metadata.create_all) and disposes engine on shutdown. CORS allows frontend requests.
  </action>
  <verify>
Validate main.py:
- grep "lifespan" backend/main.py
- grep "CORSMiddleware" backend/main.py
- grep "engine.dispose" backend/main.py
- grep "include_router" backend/main.py
  </verify>
  <done>
FastAPI application created with lifespan events for database initialization and CORS middleware for frontend integration
  </done>
</task>

<task type="auto">
  <name>Create health check endpoint with database connectivity test</name>
  <files>
    backend/api/__init__.py
    backend/api/routes/__init__.py
    backend/api/routes/health.py
  </files>
  <action>
Create health endpoint to verify database connectivity:

1. Create backend/api/__init__.py (empty marker file)

2. Create backend/api/routes/__init__.py (empty marker file)

3. Create backend/api/routes/health.py:
   - Import APIRouter, Depends from fastapi
   - Import AsyncSession from sqlalchemy.ext.asyncio
   - Import text from sqlalchemy
   - Import get_session from backend.db.session
   - Create router = APIRouter(tags=["health"])

4. Define health endpoint:
   - @router.get("/health")
   - async def health_check(session: AsyncSession = Depends(get_session))
   - Try to execute: result = await session.execute(text("SELECT 1"))
   - Fetch result: result.scalar_one()
   - Return: {"status": "healthy", "database": "connected"}
   - On exception: return {"status": "unhealthy", "database": "disconnected", "error": str(e)}

This endpoint verifies:
- FastAPI application is running
- Database session dependency works
- PostgreSQL connection is live
- Async query execution succeeds
  </action>
  <verify>
Validate health endpoint:
- grep "def health_check" backend/api/routes/health.py
- grep "SELECT 1" backend/api/routes/health.py
- grep "get_session" backend/api/routes/health.py
  </verify>
  <done>
Health endpoint created that tests database connectivity via async session, returning connection status
  </done>
</task>

<task type="auto">
  <name>Define curated entity constants for Phase 2 ingestion</name>
  <files>
    backend/utils/__init__.py
    backend/utils/constants.py
  </files>
  <action>
Create constants module with curated entity list:

1. Create backend/utils/__init__.py (empty marker file)

2. Create backend/utils/constants.py:
   - Define CURATED_ENTITIES list of dicts:
     * {"name": "GPT-4o", "category": "model"}
     * {"name": "Claude", "category": "model"}
     * {"name": "Gemini", "category": "model"}
     * {"name": "Llama", "category": "model"}
     * {"name": "Mistral", "category": "model"}
     * {"name": "Cursor", "category": "tool"}
     * {"name": "Lovable", "category": "tool"}
     * {"name": "v0", "category": "tool"}
     * {"name": "GitHub Copilot", "category": "tool"}
     * {"name": "Replit", "category": "tool"}
   - Add comment: "Fixed curated entity list for controlled API costs and consistent tracking (from PROJECT.md)"
   - Define ENTITY_NAMES = [e["name"] for e in CURATED_ENTITIES] for quick access

This matches the requirement from PROJECT.md: "Fixed curated entity list (AI models: GPT-4o, Claude, Gemini, Llama, Mistral; AI tools: Cursor, Lovable, v0, GitHub Copilot, Replit)"
  </action>
  <verify>
Validate constants:
- grep "GPT-4o" backend/utils/constants.py
- grep "Cursor" backend/utils/constants.py
- grep "CURATED_ENTITIES" backend/utils/constants.py
- python -c "from backend.utils.constants import CURATED_ENTITIES; assert len(CURATED_ENTITIES) == 10"
  </verify>
  <done>
Curated entity list defined as constants, ready for Phase 2 to populate entities table and use for AskNews filters
  </done>
</task>

<task type="auto">
  <name>Start full Docker Compose stack and verify health endpoint</name>
  <files>
    N/A (verification only)
  </files>
  <action>
Verify complete stack startup:

1. Clean up existing containers:
   - docker-compose down -v

2. Start full stack:
   - docker-compose up -d
   - Wait 15 seconds for services to start

3. Verify PostgreSQL is healthy:
   - docker-compose ps | grep postgres | grep "healthy"

4. Verify backend container is running:
   - docker-compose ps | grep backend | grep "Up"

5. Test health endpoint:
   - curl http://localhost:8000/health
   - Should return: {"status":"healthy","database":"connected"}

6. View backend logs for startup messages:
   - docker-compose logs backend | grep "Starting up application"

7. Leave services running for manual verification
  </action>
  <verify>
Commands succeed:
- docker-compose up -d
- sleep 15
- curl http://localhost:8000/health | grep "healthy"
- docker-compose ps | grep "Up.*healthy"
  </verify>
  <done>
Full Docker Compose stack running with FastAPI accessible at http://localhost:8000 and health endpoint confirming database connectivity
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 1 foundation: Docker Compose stack with PostgreSQL database, SQLAlchemy async models, Alembic migrations, and FastAPI application with health endpoint.

Stack components:
- PostgreSQL 16 container with healthcheck
- FastAPI backend container with live reload
- Database schema: entities, articles, sentiment_timeseries tables
- Health endpoint at /health confirming database connectivity
  </what-built>
  <how-to-verify>
1. Visit http://localhost:8000/health in browser
   - Should show: {"status":"healthy","database":"connected"}

2. Visit http://localhost:8000/docs in browser
   - FastAPI auto-generated OpenAPI documentation
   - Should show GET /health endpoint

3. Verify database schema:
   - Run: docker-compose exec postgres psql -U vibecheck -d vibecheck -c "\dt"
   - Should list tables: entities, articles, sentiment_timeseries, alembic_version

4. Verify database indexes:
   - Run: docker-compose exec postgres psql -U vibecheck -d vibecheck -c "\di"
   - Should show indexes on published_at, external_id, entity_id+timestamp

5. Test hot reload (optional):
   - Edit backend/api/routes/health.py to change response message
   - Save file
   - Re-visit http://localhost:8000/health
   - Should reflect changes immediately (no container restart)

6. Check logs for any errors:
   - Run: docker-compose logs backend
   - Should show "Starting up application..." with no errors

Expected outcome: All services healthy, health endpoint returns database:connected, schema tables exist with correct indexes.
  </how-to-verify>
  <resume-signal>Type "approved" if verification passes, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
After completion, verify:
1. docker-compose up -d starts both postgres and backend services
2. curl http://localhost:8000/health returns {"status":"healthy","database":"connected"}
3. http://localhost:8000/docs shows FastAPI OpenAPI documentation
4. PostgreSQL contains entities, articles, sentiment_timeseries tables
5. All Phase 1 success criteria met (from ROADMAP.md)
</verification>

<success_criteria>
- FastAPI application starts successfully via Docker Compose
- Health endpoint confirms database connectivity
- All three tables exist with proper indexes and constraints
- Docker Compose orchestration works (backend waits for healthy postgres)
- Curated entity list defined for Phase 2 ingestion
- Application logs show successful startup with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-storage/01-03-SUMMARY.md`
</output>
